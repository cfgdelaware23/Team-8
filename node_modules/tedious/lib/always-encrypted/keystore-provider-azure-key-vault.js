"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColumnEncryptionAzureKeyVaultProvider = void 0;
var _identity = require("@azure/identity");
var _keyvaultKeys = require("@azure/keyvault-keys");
var _crypto = require("crypto");
var _url = require("url");
// This code is based on the `mssql-jdbc` library published under the conditions of MIT license.
// Copyright (c) 2019 Microsoft Corporation

class ColumnEncryptionAzureKeyVaultProvider {
  name;
  url;
  rsaEncryptionAlgorithmWithOAEPForAKV;
  firstVersion;
  credentials;
  azureKeyVaultDomainName;
  keyClient;
  constructor(clientId, clientKey, tenantId) {
    this.name = 'AZURE_KEY_VAULT';
    this.azureKeyVaultDomainName = 'vault.azure.net';
    this.rsaEncryptionAlgorithmWithOAEPForAKV = 'RSA-OAEP';
    this.firstVersion = Buffer.from([0x01]);
    this.credentials = new _identity.ClientSecretCredential(tenantId, clientId, clientKey);
  }
  async decryptColumnEncryptionKey(masterKeyPath, encryptionAlgorithm, encryptedColumnEncryptionKey) {
    if (!encryptedColumnEncryptionKey) {
      throw new Error('Internal error. Encrypted column encryption key cannot be null.');
    }
    if (encryptedColumnEncryptionKey.length === 0) {
      throw new Error('Internal error. Empty encrypted column encryption key specified.');
    }
    encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);
    const masterKey = await this.getMasterKey(masterKeyPath);
    const keySizeInBytes = this.getAKVKeySize(masterKey);
    const cryptoClient = this.createCryptoClient(masterKey);
    if (encryptedColumnEncryptionKey[0] !== this.firstVersion[0]) {
      throw new Error(`Specified encrypted column encryption key contains an invalid encryption algorithm version ${Buffer.from([encryptedColumnEncryptionKey[0]]).toString('hex')}. Expected version is ${Buffer.from([this.firstVersion[0]]).toString('hex')}.`);
    }
    let currentIndex = this.firstVersion.length;
    const keyPathLength = encryptedColumnEncryptionKey.readInt16LE(currentIndex);
    currentIndex += 2;
    const cipherTextLength = encryptedColumnEncryptionKey.readInt16LE(currentIndex);
    currentIndex += 2;
    currentIndex += keyPathLength;
    if (cipherTextLength !== keySizeInBytes) {
      throw new Error(`The specified encrypted column encryption key's ciphertext length: ${cipherTextLength} does not match the ciphertext length: ${keySizeInBytes} when using column master key (Azure Key Vault key) in ${masterKeyPath}. The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.`);
    }
    const signatureLength = encryptedColumnEncryptionKey.length - currentIndex - cipherTextLength;
    if (signatureLength !== keySizeInBytes) {
      throw new Error(`The specified encrypted column encryption key's signature length: ${signatureLength} does not match the signature length: ${keySizeInBytes} when using column master key (Azure Key Vault key) in ${masterKeyPath}. The encrypted column encryption key may be corrupt, or the specified Azure Key Vault key path may be incorrect.`);
    }
    const cipherText = Buffer.alloc(cipherTextLength);
    encryptedColumnEncryptionKey.copy(cipherText, 0, currentIndex, currentIndex + cipherTextLength);
    currentIndex += cipherTextLength;
    const signature = Buffer.alloc(signatureLength);
    encryptedColumnEncryptionKey.copy(signature, 0, currentIndex, currentIndex + signatureLength);
    const hash = Buffer.alloc(encryptedColumnEncryptionKey.length - signature.length);
    encryptedColumnEncryptionKey.copy(hash, 0, 0, encryptedColumnEncryptionKey.length - signature.length);
    const messageDigest = (0, _crypto.createHash)('sha256');
    messageDigest.update(hash);
    const dataToVerify = messageDigest.digest();
    if (!dataToVerify) {
      throw new Error('Hash should not be null while decrypting encrypted column encryption key.');
    }
    const verifyKey = await cryptoClient.verify('RS256', dataToVerify, signature);
    if (!verifyKey.result) {
      throw new Error(`The specified encrypted column encryption key signature does not match the signature computed with the column master key (Asymmetric key in Azure Key Vault) in ${masterKeyPath}. The encrypted column encryption key may be corrupt, or the specified path may be incorrect.`);
    }
    const decryptedCEK = await this.azureKeyVaultUnWrap(cryptoClient, encryptionAlgorithm, cipherText);
    return decryptedCEK;
  }
  async encryptColumnEncryptionKey(masterKeyPath, encryptionAlgorithm, columnEncryptionKey) {
    if (!columnEncryptionKey) {
      throw new Error('Column encryption key cannot be null.');
    }
    if (columnEncryptionKey.length === 0) {
      throw new Error('Empty column encryption key specified.');
    }
    encryptionAlgorithm = this.validateEncryptionAlgorithm(encryptionAlgorithm);
    const masterKey = await this.getMasterKey(masterKeyPath);
    const keySizeInBytes = this.getAKVKeySize(masterKey);
    const cryptoClient = this.createCryptoClient(masterKey);
    const version = Buffer.from([this.firstVersion[0]]);
    const masterKeyPathBytes = Buffer.from(masterKeyPath.toLowerCase(), 'utf8');
    const keyPathLength = Buffer.alloc(2);
    keyPathLength[0] = masterKeyPathBytes.length & 0xff;
    keyPathLength[1] = masterKeyPathBytes.length >> 8 & 0xff;
    const cipherText = await this.azureKeyVaultWrap(cryptoClient, encryptionAlgorithm, columnEncryptionKey);
    const cipherTextLength = Buffer.alloc(2);
    cipherTextLength[0] = cipherText.length & 0xff;
    cipherTextLength[1] = cipherText.length >> 8 & 0xff;
    if (cipherText.length !== keySizeInBytes) {
      throw new Error('CipherText length does not match the RSA key size.');
    }
    const dataToHash = Buffer.alloc(version.length + keyPathLength.length + cipherTextLength.length + masterKeyPathBytes.length + cipherText.length);
    let destinationPosition = version.length;
    version.copy(dataToHash, 0, 0, version.length);
    keyPathLength.copy(dataToHash, destinationPosition, 0, keyPathLength.length);
    destinationPosition += keyPathLength.length;
    cipherTextLength.copy(dataToHash, destinationPosition, 0, cipherTextLength.length);
    destinationPosition += cipherTextLength.length;
    masterKeyPathBytes.copy(dataToHash, destinationPosition, 0, masterKeyPathBytes.length);
    destinationPosition += masterKeyPathBytes.length;
    cipherText.copy(dataToHash, destinationPosition, 0, cipherText.length);
    const messageDigest = (0, _crypto.createHash)('sha256');
    messageDigest.update(dataToHash);
    const dataToSign = messageDigest.digest();
    const signedHash = await this.azureKeyVaultSignedHashedData(cryptoClient, dataToSign);
    if (signedHash.length !== keySizeInBytes) {
      throw new Error('Signed hash length does not match the RSA key size.');
    }
    const verifyKey = await cryptoClient.verify('RS256', dataToSign, signedHash);
    if (!verifyKey.result) {
      throw new Error('Invalid signature of the encrypted column encryption key computed.');
    }
    const encryptedColumnEncryptionKeyLength = version.length + cipherTextLength.length + keyPathLength.length + cipherText.length + masterKeyPathBytes.length + signedHash.length;
    const encryptedColumnEncryptionKey = Buffer.alloc(encryptedColumnEncryptionKeyLength);
    let currentIndex = 0;
    version.copy(encryptedColumnEncryptionKey, currentIndex, 0, version.length);
    currentIndex += version.length;
    keyPathLength.copy(encryptedColumnEncryptionKey, currentIndex, 0, keyPathLength.length);
    currentIndex += keyPathLength.length;
    cipherTextLength.copy(encryptedColumnEncryptionKey, currentIndex, 0, cipherTextLength.length);
    currentIndex += cipherTextLength.length;
    masterKeyPathBytes.copy(encryptedColumnEncryptionKey, currentIndex, 0, masterKeyPathBytes.length);
    currentIndex += masterKeyPathBytes.length;
    cipherText.copy(encryptedColumnEncryptionKey, currentIndex, 0, cipherText.length);
    currentIndex += cipherText.length;
    signedHash.copy(encryptedColumnEncryptionKey, currentIndex, 0, signedHash.length);
    return encryptedColumnEncryptionKey;
  }
  async getMasterKey(masterKeyPath) {
    if (!masterKeyPath) {
      throw new Error('Master key path cannot be null or undefined');
    }
    const keyParts = this.parsePath(masterKeyPath);
    this.createKeyClient(keyParts.vaultUrl);
    return await this.keyClient.getKey(keyParts.name, keyParts.version ? {
      version: keyParts.version
    } : {});
  }
  createKeyClient(keyVaultUrl) {
    if (!keyVaultUrl) {
      throw new Error('Cannot create key client with null or undefined keyVaultUrl');
    }
    if (!this.keyClient) {
      this.url = keyVaultUrl;
      this.keyClient = new _keyvaultKeys.KeyClient(keyVaultUrl, this.credentials);
    }
  }
  createCryptoClient(masterKey) {
    if (!masterKey) {
      throw new Error('Cannot create CryptographyClient with null or undefined masterKey');
    }
    return new _keyvaultKeys.CryptographyClient(masterKey, this.credentials);
  }
  parsePath(masterKeyPath) {
    if (!masterKeyPath || masterKeyPath.trim() === '') {
      throw new Error('Azure Key Vault key path cannot be null.');
    }
    let baseUri;
    try {
      baseUri = (0, _url.parse)(masterKeyPath, true, true);
    } catch {
      throw new Error(`Invalid keys identifier: ${masterKeyPath}. Not a valid URI`);
    }
    if (!baseUri.hostname || !baseUri.hostname.toLowerCase().endsWith(this.azureKeyVaultDomainName)) {
      throw new Error(`Invalid Azure Key Vault key path specified: ${masterKeyPath}.`);
    }

    // Path is of the form '/collection/name[/version]'
    const segments = (baseUri.pathname || '').split('/');
    if (segments.length !== 3 && segments.length !== 4) {
      throw new Error(`Invalid keys identifier: ${masterKeyPath}. Bad number of segments: ${segments.length}`);
    }
    if ('keys' !== segments[1]) {
      throw new Error(`Invalid keys identifier: ${masterKeyPath}. segment [1] should be "keys", found "${segments[1]}"`);
    }
    const vaultUrl = `${baseUri.protocol}//${baseUri.host}`;
    const name = segments[2];
    const version = segments.length === 4 ? segments[3] : undefined;
    return {
      vaultUrl,
      name,
      version
    };
  }
  async azureKeyVaultSignedHashedData(cryptoClient, dataToSign) {
    if (!cryptoClient) {
      throw new Error('Azure KVS Crypto Client is not defined.');
    }
    const signedData = await cryptoClient.sign('RS256', dataToSign);
    return Buffer.from(signedData.result);
  }
  async azureKeyVaultWrap(cryptoClient, encryptionAlgorithm, columnEncryptionKey) {
    if (!cryptoClient) {
      throw new Error('Azure KVS Crypto Client is not defined.');
    }
    if (!columnEncryptionKey) {
      throw new Error('Column encryption key cannot be null.');
    }
    const wrappedKey = await cryptoClient.wrapKey(encryptionAlgorithm, columnEncryptionKey);
    return Buffer.from(wrappedKey.result);
  }
  async azureKeyVaultUnWrap(cryptoClient, encryptionAlgorithm, encryptedColumnEncryptionKey) {
    if (!cryptoClient) {
      throw new Error('Azure KVS Crypto Client is not defined.');
    }
    if (!encryptionAlgorithm) {
      throw new Error('Encryption Algorithm cannot be null or undefined');
    }
    if (!encryptedColumnEncryptionKey) {
      throw new Error('Encrypted column encryption key cannot be null.');
    }
    if (encryptedColumnEncryptionKey.length === 0) {
      throw new Error('Encrypted Column Encryption Key length should not be zero.');
    }
    const unwrappedKey = await cryptoClient.unwrapKey(encryptionAlgorithm, encryptedColumnEncryptionKey);
    return Buffer.from(unwrappedKey.result);
  }
  getAKVKeySize(retrievedKey) {
    if (!retrievedKey) {
      throw new Error('Retrieved key cannot be null or undefined');
    }
    const key = retrievedKey.key;
    if (!key) {
      throw new Error(`Key does not exist ${retrievedKey.name}`);
    }
    const kty = key && key.kty && key.kty.toString().toUpperCase();
    if (!kty || 'RSA'.localeCompare(kty, 'en') !== 0) {
      throw new Error(`Cannot use a non-RSA key: ${kty}.`);
    }
    const keyLength = key && key.n && key.n.length;
    return keyLength || 0;
  }
  validateEncryptionAlgorithm(encryptionAlgorithm) {
    if (!encryptionAlgorithm) {
      throw new Error('Key encryption algorithm cannot be null.');
    }
    if ('RSA_OAEP'.localeCompare(encryptionAlgorithm.toUpperCase(), 'en') === 0) {
      encryptionAlgorithm = 'RSA-OAEP';
    }
    if (this.rsaEncryptionAlgorithmWithOAEPForAKV.localeCompare(encryptionAlgorithm.trim().toUpperCase(), 'en') !== 0) {
      throw new Error(`Invalid key encryption algorithm specified: ${encryptionAlgorithm}. Expected value: ${this.rsaEncryptionAlgorithmWithOAEPForAKV}.`);
    }
    return encryptionAlgorithm;
  }
}
exports.ColumnEncryptionAzureKeyVaultProvider = ColumnEncryptionAzureKeyVaultProvider;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfaWRlbnRpdHkiLCJyZXF1aXJlIiwiX2tleXZhdWx0S2V5cyIsIl9jcnlwdG8iLCJfdXJsIiwiQ29sdW1uRW5jcnlwdGlvbkF6dXJlS2V5VmF1bHRQcm92aWRlciIsIm5hbWUiLCJ1cmwiLCJyc2FFbmNyeXB0aW9uQWxnb3JpdGhtV2l0aE9BRVBGb3JBS1YiLCJmaXJzdFZlcnNpb24iLCJjcmVkZW50aWFscyIsImF6dXJlS2V5VmF1bHREb21haW5OYW1lIiwia2V5Q2xpZW50IiwiY29uc3RydWN0b3IiLCJjbGllbnRJZCIsImNsaWVudEtleSIsInRlbmFudElkIiwiQnVmZmVyIiwiZnJvbSIsIkNsaWVudFNlY3JldENyZWRlbnRpYWwiLCJkZWNyeXB0Q29sdW1uRW5jcnlwdGlvbktleSIsIm1hc3RlcktleVBhdGgiLCJlbmNyeXB0aW9uQWxnb3JpdGhtIiwiZW5jcnlwdGVkQ29sdW1uRW5jcnlwdGlvbktleSIsIkVycm9yIiwibGVuZ3RoIiwidmFsaWRhdGVFbmNyeXB0aW9uQWxnb3JpdGhtIiwibWFzdGVyS2V5IiwiZ2V0TWFzdGVyS2V5Iiwia2V5U2l6ZUluQnl0ZXMiLCJnZXRBS1ZLZXlTaXplIiwiY3J5cHRvQ2xpZW50IiwiY3JlYXRlQ3J5cHRvQ2xpZW50IiwidG9TdHJpbmciLCJjdXJyZW50SW5kZXgiLCJrZXlQYXRoTGVuZ3RoIiwicmVhZEludDE2TEUiLCJjaXBoZXJUZXh0TGVuZ3RoIiwic2lnbmF0dXJlTGVuZ3RoIiwiY2lwaGVyVGV4dCIsImFsbG9jIiwiY29weSIsInNpZ25hdHVyZSIsImhhc2giLCJtZXNzYWdlRGlnZXN0IiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsImRhdGFUb1ZlcmlmeSIsImRpZ2VzdCIsInZlcmlmeUtleSIsInZlcmlmeSIsInJlc3VsdCIsImRlY3J5cHRlZENFSyIsImF6dXJlS2V5VmF1bHRVbldyYXAiLCJlbmNyeXB0Q29sdW1uRW5jcnlwdGlvbktleSIsImNvbHVtbkVuY3J5cHRpb25LZXkiLCJ2ZXJzaW9uIiwibWFzdGVyS2V5UGF0aEJ5dGVzIiwidG9Mb3dlckNhc2UiLCJhenVyZUtleVZhdWx0V3JhcCIsImRhdGFUb0hhc2giLCJkZXN0aW5hdGlvblBvc2l0aW9uIiwiZGF0YVRvU2lnbiIsInNpZ25lZEhhc2giLCJhenVyZUtleVZhdWx0U2lnbmVkSGFzaGVkRGF0YSIsImVuY3J5cHRlZENvbHVtbkVuY3J5cHRpb25LZXlMZW5ndGgiLCJrZXlQYXJ0cyIsInBhcnNlUGF0aCIsImNyZWF0ZUtleUNsaWVudCIsInZhdWx0VXJsIiwiZ2V0S2V5Iiwia2V5VmF1bHRVcmwiLCJLZXlDbGllbnQiLCJDcnlwdG9ncmFwaHlDbGllbnQiLCJ0cmltIiwiYmFzZVVyaSIsInBhcnNlIiwiaG9zdG5hbWUiLCJlbmRzV2l0aCIsInNlZ21lbnRzIiwicGF0aG5hbWUiLCJzcGxpdCIsInByb3RvY29sIiwiaG9zdCIsInVuZGVmaW5lZCIsInNpZ25lZERhdGEiLCJzaWduIiwid3JhcHBlZEtleSIsIndyYXBLZXkiLCJ1bndyYXBwZWRLZXkiLCJ1bndyYXBLZXkiLCJyZXRyaWV2ZWRLZXkiLCJrZXkiLCJrdHkiLCJ0b1VwcGVyQ2FzZSIsImxvY2FsZUNvbXBhcmUiLCJrZXlMZW5ndGgiLCJuIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hbHdheXMtZW5jcnlwdGVkL2tleXN0b3JlLXByb3ZpZGVyLWF6dXJlLWtleS12YXVsdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGNvZGUgaXMgYmFzZWQgb24gdGhlIGBtc3NxbC1qZGJjYCBsaWJyYXJ5IHB1Ymxpc2hlZCB1bmRlciB0aGUgY29uZGl0aW9ucyBvZiBNSVQgbGljZW5zZS5cbi8vIENvcHlyaWdodCAoYykgMjAxOSBNaWNyb3NvZnQgQ29ycG9yYXRpb25cblxuaW1wb3J0IHsgQ2xpZW50U2VjcmV0Q3JlZGVudGlhbCB9IGZyb20gJ0BhenVyZS9pZGVudGl0eSc7XG5pbXBvcnQgeyBDcnlwdG9ncmFwaHlDbGllbnQsIHR5cGUgS2V5V3JhcEFsZ29yaXRobSwgS2V5Q2xpZW50LCB0eXBlIEtleVZhdWx0S2V5IH0gZnJvbSAnQGF6dXJlL2tleXZhdWx0LWtleXMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaCB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJ3VybCc7XG5cbmludGVyZmFjZSBQYXJzZWRLZXlQYXRoIHtcbiAgdmF1bHRVcmw6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICB2ZXJzaW9uPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgY2xhc3MgQ29sdW1uRW5jcnlwdGlvbkF6dXJlS2V5VmF1bHRQcm92aWRlciB7XG4gIHB1YmxpYyByZWFkb25seSBuYW1lOiBzdHJpbmc7XG4gIHByaXZhdGUgdXJsOiB1bmRlZmluZWQgfCBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgcnNhRW5jcnlwdGlvbkFsZ29yaXRobVdpdGhPQUVQRm9yQUtWOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgZmlyc3RWZXJzaW9uOiBCdWZmZXI7XG4gIHByaXZhdGUgY3JlZGVudGlhbHM6IENsaWVudFNlY3JldENyZWRlbnRpYWw7XG4gIHByaXZhdGUgcmVhZG9ubHkgYXp1cmVLZXlWYXVsdERvbWFpbk5hbWU6IHN0cmluZztcbiAgcHJpdmF0ZSBrZXlDbGllbnQ6IHVuZGVmaW5lZCB8IEtleUNsaWVudDtcblxuICBjb25zdHJ1Y3RvcihjbGllbnRJZDogc3RyaW5nLCBjbGllbnRLZXk6IHN0cmluZywgdGVuYW50SWQ6IHN0cmluZykge1xuICAgIHRoaXMubmFtZSA9ICdBWlVSRV9LRVlfVkFVTFQnO1xuICAgIHRoaXMuYXp1cmVLZXlWYXVsdERvbWFpbk5hbWUgPSAndmF1bHQuYXp1cmUubmV0JztcbiAgICB0aGlzLnJzYUVuY3J5cHRpb25BbGdvcml0aG1XaXRoT0FFUEZvckFLViA9ICdSU0EtT0FFUCc7XG4gICAgdGhpcy5maXJzdFZlcnNpb24gPSBCdWZmZXIuZnJvbShbMHgwMV0pO1xuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBuZXcgQ2xpZW50U2VjcmV0Q3JlZGVudGlhbCh0ZW5hbnRJZCwgY2xpZW50SWQsIGNsaWVudEtleSk7XG4gIH1cblxuICBhc3luYyBkZWNyeXB0Q29sdW1uRW5jcnlwdGlvbktleShtYXN0ZXJLZXlQYXRoOiBzdHJpbmcsIGVuY3J5cHRpb25BbGdvcml0aG06IHN0cmluZywgZW5jcnlwdGVkQ29sdW1uRW5jcnlwdGlvbktleTogQnVmZmVyKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgICBpZiAoIWVuY3J5cHRlZENvbHVtbkVuY3J5cHRpb25LZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWwgZXJyb3IuIEVuY3J5cHRlZCBjb2x1bW4gZW5jcnlwdGlvbiBrZXkgY2Fubm90IGJlIG51bGwuJyk7XG4gICAgfVxuXG4gICAgaWYgKGVuY3J5cHRlZENvbHVtbkVuY3J5cHRpb25LZXkubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIGVycm9yLiBFbXB0eSBlbmNyeXB0ZWQgY29sdW1uIGVuY3J5cHRpb24ga2V5IHNwZWNpZmllZC4nKTtcbiAgICB9XG5cbiAgICBlbmNyeXB0aW9uQWxnb3JpdGhtID0gdGhpcy52YWxpZGF0ZUVuY3J5cHRpb25BbGdvcml0aG0oZW5jcnlwdGlvbkFsZ29yaXRobSk7XG5cbiAgICBjb25zdCBtYXN0ZXJLZXkgPSBhd2FpdCB0aGlzLmdldE1hc3RlcktleShtYXN0ZXJLZXlQYXRoKTtcblxuICAgIGNvbnN0IGtleVNpemVJbkJ5dGVzID0gdGhpcy5nZXRBS1ZLZXlTaXplKG1hc3RlcktleSk7XG5cbiAgICBjb25zdCBjcnlwdG9DbGllbnQgPSB0aGlzLmNyZWF0ZUNyeXB0b0NsaWVudChtYXN0ZXJLZXkpO1xuXG4gICAgaWYgKGVuY3J5cHRlZENvbHVtbkVuY3J5cHRpb25LZXlbMF0gIT09IHRoaXMuZmlyc3RWZXJzaW9uWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNwZWNpZmllZCBlbmNyeXB0ZWQgY29sdW1uIGVuY3J5cHRpb24ga2V5IGNvbnRhaW5zIGFuIGludmFsaWQgZW5jcnlwdGlvbiBhbGdvcml0aG0gdmVyc2lvbiAke0J1ZmZlci5mcm9tKFtlbmNyeXB0ZWRDb2x1bW5FbmNyeXB0aW9uS2V5WzBdXSkudG9TdHJpbmcoJ2hleCcpfS4gRXhwZWN0ZWQgdmVyc2lvbiBpcyAke0J1ZmZlci5mcm9tKFt0aGlzLmZpcnN0VmVyc2lvblswXV0pLnRvU3RyaW5nKCdoZXgnKX0uYCk7XG4gICAgfVxuXG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuZmlyc3RWZXJzaW9uLmxlbmd0aDtcbiAgICBjb25zdCBrZXlQYXRoTGVuZ3RoOiBudW1iZXIgPSBlbmNyeXB0ZWRDb2x1bW5FbmNyeXB0aW9uS2V5LnJlYWRJbnQxNkxFKGN1cnJlbnRJbmRleCk7XG5cbiAgICBjdXJyZW50SW5kZXggKz0gMjtcblxuICAgIGNvbnN0IGNpcGhlclRleHRMZW5ndGg6IG51bWJlciA9IGVuY3J5cHRlZENvbHVtbkVuY3J5cHRpb25LZXkucmVhZEludDE2TEUoY3VycmVudEluZGV4KTtcblxuICAgIGN1cnJlbnRJbmRleCArPSAyO1xuXG4gICAgY3VycmVudEluZGV4ICs9IGtleVBhdGhMZW5ndGg7XG5cbiAgICBpZiAoY2lwaGVyVGV4dExlbmd0aCAhPT0ga2V5U2l6ZUluQnl0ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHNwZWNpZmllZCBlbmNyeXB0ZWQgY29sdW1uIGVuY3J5cHRpb24ga2V5J3MgY2lwaGVydGV4dCBsZW5ndGg6ICR7Y2lwaGVyVGV4dExlbmd0aH0gZG9lcyBub3QgbWF0Y2ggdGhlIGNpcGhlcnRleHQgbGVuZ3RoOiAke2tleVNpemVJbkJ5dGVzfSB3aGVuIHVzaW5nIGNvbHVtbiBtYXN0ZXIga2V5IChBenVyZSBLZXkgVmF1bHQga2V5KSBpbiAke21hc3RlcktleVBhdGh9LiBUaGUgZW5jcnlwdGVkIGNvbHVtbiBlbmNyeXB0aW9uIGtleSBtYXkgYmUgY29ycnVwdCwgb3IgdGhlIHNwZWNpZmllZCBBenVyZSBLZXkgVmF1bHQga2V5IHBhdGggbWF5IGJlIGluY29ycmVjdC5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaWduYXR1cmVMZW5ndGg6IG51bWJlciA9IGVuY3J5cHRlZENvbHVtbkVuY3J5cHRpb25LZXkubGVuZ3RoIC0gY3VycmVudEluZGV4IC0gY2lwaGVyVGV4dExlbmd0aDtcblxuICAgIGlmIChzaWduYXR1cmVMZW5ndGggIT09IGtleVNpemVJbkJ5dGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzcGVjaWZpZWQgZW5jcnlwdGVkIGNvbHVtbiBlbmNyeXB0aW9uIGtleSdzIHNpZ25hdHVyZSBsZW5ndGg6ICR7c2lnbmF0dXJlTGVuZ3RofSBkb2VzIG5vdCBtYXRjaCB0aGUgc2lnbmF0dXJlIGxlbmd0aDogJHtrZXlTaXplSW5CeXRlc30gd2hlbiB1c2luZyBjb2x1bW4gbWFzdGVyIGtleSAoQXp1cmUgS2V5IFZhdWx0IGtleSkgaW4gJHttYXN0ZXJLZXlQYXRofS4gVGhlIGVuY3J5cHRlZCBjb2x1bW4gZW5jcnlwdGlvbiBrZXkgbWF5IGJlIGNvcnJ1cHQsIG9yIHRoZSBzcGVjaWZpZWQgQXp1cmUgS2V5IFZhdWx0IGtleSBwYXRoIG1heSBiZSBpbmNvcnJlY3QuYCk7XG4gICAgfVxuXG4gICAgY29uc3QgY2lwaGVyVGV4dCA9IEJ1ZmZlci5hbGxvYyhjaXBoZXJUZXh0TGVuZ3RoKTtcbiAgICBlbmNyeXB0ZWRDb2x1bW5FbmNyeXB0aW9uS2V5LmNvcHkoY2lwaGVyVGV4dCwgMCwgY3VycmVudEluZGV4LCBjdXJyZW50SW5kZXggKyBjaXBoZXJUZXh0TGVuZ3RoKTtcbiAgICBjdXJyZW50SW5kZXggKz0gY2lwaGVyVGV4dExlbmd0aDtcblxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IEJ1ZmZlci5hbGxvYyhzaWduYXR1cmVMZW5ndGgpO1xuICAgIGVuY3J5cHRlZENvbHVtbkVuY3J5cHRpb25LZXkuY29weShzaWduYXR1cmUsIDAsIGN1cnJlbnRJbmRleCwgY3VycmVudEluZGV4ICsgc2lnbmF0dXJlTGVuZ3RoKTtcblxuICAgIGNvbnN0IGhhc2ggPSBCdWZmZXIuYWxsb2MoZW5jcnlwdGVkQ29sdW1uRW5jcnlwdGlvbktleS5sZW5ndGggLSBzaWduYXR1cmUubGVuZ3RoKTtcbiAgICBlbmNyeXB0ZWRDb2x1bW5FbmNyeXB0aW9uS2V5LmNvcHkoaGFzaCwgMCwgMCwgZW5jcnlwdGVkQ29sdW1uRW5jcnlwdGlvbktleS5sZW5ndGggLSBzaWduYXR1cmUubGVuZ3RoKTtcblxuICAgIGNvbnN0IG1lc3NhZ2VEaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgICBtZXNzYWdlRGlnZXN0LnVwZGF0ZShoYXNoKTtcblxuICAgIGNvbnN0IGRhdGFUb1ZlcmlmeTogQnVmZmVyID0gbWVzc2FnZURpZ2VzdC5kaWdlc3QoKTtcblxuICAgIGlmICghZGF0YVRvVmVyaWZ5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIG5vdCBiZSBudWxsIHdoaWxlIGRlY3J5cHRpbmcgZW5jcnlwdGVkIGNvbHVtbiBlbmNyeXB0aW9uIGtleS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCB2ZXJpZnlLZXkgPSBhd2FpdCBjcnlwdG9DbGllbnQudmVyaWZ5KCdSUzI1NicsIGRhdGFUb1ZlcmlmeSwgc2lnbmF0dXJlKTtcbiAgICBpZiAoIXZlcmlmeUtleS5yZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHNwZWNpZmllZCBlbmNyeXB0ZWQgY29sdW1uIGVuY3J5cHRpb24ga2V5IHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCB0aGUgc2lnbmF0dXJlIGNvbXB1dGVkIHdpdGggdGhlIGNvbHVtbiBtYXN0ZXIga2V5IChBc3ltbWV0cmljIGtleSBpbiBBenVyZSBLZXkgVmF1bHQpIGluICR7bWFzdGVyS2V5UGF0aH0uIFRoZSBlbmNyeXB0ZWQgY29sdW1uIGVuY3J5cHRpb24ga2V5IG1heSBiZSBjb3JydXB0LCBvciB0aGUgc3BlY2lmaWVkIHBhdGggbWF5IGJlIGluY29ycmVjdC5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWNyeXB0ZWRDRUs6IEJ1ZmZlciA9IGF3YWl0IHRoaXMuYXp1cmVLZXlWYXVsdFVuV3JhcChjcnlwdG9DbGllbnQsIGVuY3J5cHRpb25BbGdvcml0aG0sIGNpcGhlclRleHQpO1xuXG4gICAgcmV0dXJuIGRlY3J5cHRlZENFSztcbiAgfVxuXG4gIGFzeW5jIGVuY3J5cHRDb2x1bW5FbmNyeXB0aW9uS2V5KG1hc3RlcktleVBhdGg6IHN0cmluZywgZW5jcnlwdGlvbkFsZ29yaXRobTogc3RyaW5nLCBjb2x1bW5FbmNyeXB0aW9uS2V5OiBCdWZmZXIpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGlmICghY29sdW1uRW5jcnlwdGlvbktleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2x1bW4gZW5jcnlwdGlvbiBrZXkgY2Fubm90IGJlIG51bGwuJyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbHVtbkVuY3J5cHRpb25LZXkubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtcHR5IGNvbHVtbiBlbmNyeXB0aW9uIGtleSBzcGVjaWZpZWQuJyk7XG4gICAgfVxuXG4gICAgZW5jcnlwdGlvbkFsZ29yaXRobSA9IHRoaXMudmFsaWRhdGVFbmNyeXB0aW9uQWxnb3JpdGhtKGVuY3J5cHRpb25BbGdvcml0aG0pO1xuXG4gICAgY29uc3QgbWFzdGVyS2V5ID0gYXdhaXQgdGhpcy5nZXRNYXN0ZXJLZXkobWFzdGVyS2V5UGF0aCk7XG5cbiAgICBjb25zdCBrZXlTaXplSW5CeXRlcyA9IHRoaXMuZ2V0QUtWS2V5U2l6ZShtYXN0ZXJLZXkpO1xuXG4gICAgY29uc3QgY3J5cHRvQ2xpZW50ID0gdGhpcy5jcmVhdGVDcnlwdG9DbGllbnQobWFzdGVyS2V5KTtcblxuICAgIGNvbnN0IHZlcnNpb24gPSBCdWZmZXIuZnJvbShbdGhpcy5maXJzdFZlcnNpb25bMF1dKTtcblxuICAgIGNvbnN0IG1hc3RlcktleVBhdGhCeXRlczogQnVmZmVyID0gQnVmZmVyLmZyb20obWFzdGVyS2V5UGF0aC50b0xvd2VyQ2FzZSgpLCAndXRmOCcpO1xuXG4gICAgY29uc3Qga2V5UGF0aExlbmd0aDogQnVmZmVyID0gQnVmZmVyLmFsbG9jKDIpO1xuXG4gICAga2V5UGF0aExlbmd0aFswXSA9IG1hc3RlcktleVBhdGhCeXRlcy5sZW5ndGggJiAweGZmO1xuICAgIGtleVBhdGhMZW5ndGhbMV0gPSBtYXN0ZXJLZXlQYXRoQnl0ZXMubGVuZ3RoID4+IDggJiAweGZmO1xuXG4gICAgY29uc3QgY2lwaGVyVGV4dDogQnVmZmVyID0gYXdhaXQgdGhpcy5henVyZUtleVZhdWx0V3JhcChjcnlwdG9DbGllbnQsIGVuY3J5cHRpb25BbGdvcml0aG0sIGNvbHVtbkVuY3J5cHRpb25LZXkpO1xuXG4gICAgY29uc3QgY2lwaGVyVGV4dExlbmd0aDogQnVmZmVyID0gQnVmZmVyLmFsbG9jKDIpO1xuXG4gICAgY2lwaGVyVGV4dExlbmd0aFswXSA9IGNpcGhlclRleHQubGVuZ3RoICYgMHhmZjtcbiAgICBjaXBoZXJUZXh0TGVuZ3RoWzFdID0gY2lwaGVyVGV4dC5sZW5ndGggPj4gOCAmIDB4ZmY7XG5cbiAgICBpZiAoY2lwaGVyVGV4dC5sZW5ndGggIT09IGtleVNpemVJbkJ5dGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NpcGhlclRleHQgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIHRoZSBSU0Ega2V5IHNpemUuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YVRvSGFzaDogQnVmZmVyID0gQnVmZmVyLmFsbG9jKHZlcnNpb24ubGVuZ3RoICsga2V5UGF0aExlbmd0aC5sZW5ndGggKyBjaXBoZXJUZXh0TGVuZ3RoLmxlbmd0aCArIG1hc3RlcktleVBhdGhCeXRlcy5sZW5ndGggKyBjaXBoZXJUZXh0Lmxlbmd0aCk7XG4gICAgbGV0IGRlc3RpbmF0aW9uUG9zaXRpb246IG51bWJlciA9IHZlcnNpb24ubGVuZ3RoO1xuICAgIHZlcnNpb24uY29weShkYXRhVG9IYXNoLCAwLCAwLCB2ZXJzaW9uLmxlbmd0aCk7XG5cbiAgICBrZXlQYXRoTGVuZ3RoLmNvcHkoZGF0YVRvSGFzaCwgZGVzdGluYXRpb25Qb3NpdGlvbiwgMCwga2V5UGF0aExlbmd0aC5sZW5ndGgpO1xuICAgIGRlc3RpbmF0aW9uUG9zaXRpb24gKz0ga2V5UGF0aExlbmd0aC5sZW5ndGg7XG5cbiAgICBjaXBoZXJUZXh0TGVuZ3RoLmNvcHkoZGF0YVRvSGFzaCwgZGVzdGluYXRpb25Qb3NpdGlvbiwgMCwgY2lwaGVyVGV4dExlbmd0aC5sZW5ndGgpO1xuICAgIGRlc3RpbmF0aW9uUG9zaXRpb24gKz0gY2lwaGVyVGV4dExlbmd0aC5sZW5ndGg7XG5cbiAgICBtYXN0ZXJLZXlQYXRoQnl0ZXMuY29weShkYXRhVG9IYXNoLCBkZXN0aW5hdGlvblBvc2l0aW9uLCAwLCBtYXN0ZXJLZXlQYXRoQnl0ZXMubGVuZ3RoKTtcbiAgICBkZXN0aW5hdGlvblBvc2l0aW9uICs9IG1hc3RlcktleVBhdGhCeXRlcy5sZW5ndGg7XG5cbiAgICBjaXBoZXJUZXh0LmNvcHkoZGF0YVRvSGFzaCwgZGVzdGluYXRpb25Qb3NpdGlvbiwgMCwgY2lwaGVyVGV4dC5sZW5ndGgpO1xuXG4gICAgY29uc3QgbWVzc2FnZURpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTI1NicpO1xuXG4gICAgbWVzc2FnZURpZ2VzdC51cGRhdGUoZGF0YVRvSGFzaCk7XG5cbiAgICBjb25zdCBkYXRhVG9TaWduOiBCdWZmZXIgPSBtZXNzYWdlRGlnZXN0LmRpZ2VzdCgpO1xuXG4gICAgY29uc3Qgc2lnbmVkSGFzaDogQnVmZmVyID0gYXdhaXQgdGhpcy5henVyZUtleVZhdWx0U2lnbmVkSGFzaGVkRGF0YShjcnlwdG9DbGllbnQsIGRhdGFUb1NpZ24pO1xuICAgIGlmIChzaWduZWRIYXNoLmxlbmd0aCAhPT0ga2V5U2l6ZUluQnl0ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2lnbmVkIGhhc2ggbGVuZ3RoIGRvZXMgbm90IG1hdGNoIHRoZSBSU0Ega2V5IHNpemUuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdmVyaWZ5S2V5ID0gYXdhaXQgY3J5cHRvQ2xpZW50LnZlcmlmeSgnUlMyNTYnLCBkYXRhVG9TaWduLCBzaWduZWRIYXNoKTtcblxuICAgIGlmICghdmVyaWZ5S2V5LnJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBvZiB0aGUgZW5jcnlwdGVkIGNvbHVtbiBlbmNyeXB0aW9uIGtleSBjb21wdXRlZC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbmNyeXB0ZWRDb2x1bW5FbmNyeXB0aW9uS2V5TGVuZ3RoOiBudW1iZXIgPSB2ZXJzaW9uLmxlbmd0aCArIGNpcGhlclRleHRMZW5ndGgubGVuZ3RoICsga2V5UGF0aExlbmd0aC5sZW5ndGggKyBjaXBoZXJUZXh0Lmxlbmd0aCArIG1hc3RlcktleVBhdGhCeXRlcy5sZW5ndGggKyBzaWduZWRIYXNoLmxlbmd0aDtcbiAgICBjb25zdCBlbmNyeXB0ZWRDb2x1bW5FbmNyeXB0aW9uS2V5OiBCdWZmZXIgPSBCdWZmZXIuYWxsb2MoZW5jcnlwdGVkQ29sdW1uRW5jcnlwdGlvbktleUxlbmd0aCk7XG5cbiAgICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgICB2ZXJzaW9uLmNvcHkoZW5jcnlwdGVkQ29sdW1uRW5jcnlwdGlvbktleSwgY3VycmVudEluZGV4LCAwLCB2ZXJzaW9uLmxlbmd0aCk7XG4gICAgY3VycmVudEluZGV4ICs9IHZlcnNpb24ubGVuZ3RoO1xuXG4gICAga2V5UGF0aExlbmd0aC5jb3B5KGVuY3J5cHRlZENvbHVtbkVuY3J5cHRpb25LZXksIGN1cnJlbnRJbmRleCwgMCwga2V5UGF0aExlbmd0aC5sZW5ndGgpO1xuICAgIGN1cnJlbnRJbmRleCArPSBrZXlQYXRoTGVuZ3RoLmxlbmd0aDtcblxuICAgIGNpcGhlclRleHRMZW5ndGguY29weShlbmNyeXB0ZWRDb2x1bW5FbmNyeXB0aW9uS2V5LCBjdXJyZW50SW5kZXgsIDAsIGNpcGhlclRleHRMZW5ndGgubGVuZ3RoKTtcbiAgICBjdXJyZW50SW5kZXggKz0gY2lwaGVyVGV4dExlbmd0aC5sZW5ndGg7XG5cbiAgICBtYXN0ZXJLZXlQYXRoQnl0ZXMuY29weShlbmNyeXB0ZWRDb2x1bW5FbmNyeXB0aW9uS2V5LCBjdXJyZW50SW5kZXgsIDAsIG1hc3RlcktleVBhdGhCeXRlcy5sZW5ndGgpO1xuICAgIGN1cnJlbnRJbmRleCArPSBtYXN0ZXJLZXlQYXRoQnl0ZXMubGVuZ3RoO1xuXG4gICAgY2lwaGVyVGV4dC5jb3B5KGVuY3J5cHRlZENvbHVtbkVuY3J5cHRpb25LZXksIGN1cnJlbnRJbmRleCwgMCwgY2lwaGVyVGV4dC5sZW5ndGgpO1xuICAgIGN1cnJlbnRJbmRleCArPSBjaXBoZXJUZXh0Lmxlbmd0aDtcblxuICAgIHNpZ25lZEhhc2guY29weShlbmNyeXB0ZWRDb2x1bW5FbmNyeXB0aW9uS2V5LCBjdXJyZW50SW5kZXgsIDAsIHNpZ25lZEhhc2gubGVuZ3RoKTtcblxuICAgIHJldHVybiBlbmNyeXB0ZWRDb2x1bW5FbmNyeXB0aW9uS2V5O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRNYXN0ZXJLZXkobWFzdGVyS2V5UGF0aDogc3RyaW5nKTogUHJvbWlzZTxLZXlWYXVsdEtleT4ge1xuICAgIGlmICghbWFzdGVyS2V5UGF0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXN0ZXIga2V5IHBhdGggY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGtleVBhcnRzID0gdGhpcy5wYXJzZVBhdGgobWFzdGVyS2V5UGF0aCk7XG5cbiAgICB0aGlzLmNyZWF0ZUtleUNsaWVudChrZXlQYXJ0cy52YXVsdFVybCk7XG5cbiAgICByZXR1cm4gYXdhaXQgKHRoaXMua2V5Q2xpZW50IGFzIEtleUNsaWVudCkuZ2V0S2V5KGtleVBhcnRzLm5hbWUsIGtleVBhcnRzLnZlcnNpb24gPyB7IHZlcnNpb246IGtleVBhcnRzLnZlcnNpb24gfSA6IHt9KTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlS2V5Q2xpZW50KGtleVZhdWx0VXJsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIWtleVZhdWx0VXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUga2V5IGNsaWVudCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkIGtleVZhdWx0VXJsJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5rZXlDbGllbnQpIHtcbiAgICAgIHRoaXMudXJsID0ga2V5VmF1bHRVcmw7XG4gICAgICB0aGlzLmtleUNsaWVudCA9IG5ldyBLZXlDbGllbnQoa2V5VmF1bHRVcmwsIHRoaXMuY3JlZGVudGlhbHMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlQ3J5cHRvQ2xpZW50KG1hc3RlcktleTogS2V5VmF1bHRLZXkpOiBDcnlwdG9ncmFwaHlDbGllbnQge1xuICAgIGlmICghbWFzdGVyS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgQ3J5cHRvZ3JhcGh5Q2xpZW50IHdpdGggbnVsbCBvciB1bmRlZmluZWQgbWFzdGVyS2V5Jyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ3J5cHRvZ3JhcGh5Q2xpZW50KG1hc3RlcktleSwgdGhpcy5jcmVkZW50aWFscyk7XG4gIH1cblxuICBwcml2YXRlIHBhcnNlUGF0aChtYXN0ZXJLZXlQYXRoOiBzdHJpbmcpOiBQYXJzZWRLZXlQYXRoIHtcbiAgICBpZiAoIW1hc3RlcktleVBhdGggfHwgbWFzdGVyS2V5UGF0aC50cmltKCkgPT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F6dXJlIEtleSBWYXVsdCBrZXkgcGF0aCBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICB9XG5cbiAgICBsZXQgYmFzZVVyaTtcbiAgICB0cnkge1xuICAgICAgYmFzZVVyaSA9IHBhcnNlKG1hc3RlcktleVBhdGgsIHRydWUsIHRydWUpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGtleXMgaWRlbnRpZmllcjogJHttYXN0ZXJLZXlQYXRofS4gTm90IGEgdmFsaWQgVVJJYCk7XG4gICAgfVxuXG4gICAgaWYgKCFiYXNlVXJpLmhvc3RuYW1lIHx8ICFiYXNlVXJpLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgodGhpcy5henVyZUtleVZhdWx0RG9tYWluTmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBBenVyZSBLZXkgVmF1bHQga2V5IHBhdGggc3BlY2lmaWVkOiAke21hc3RlcktleVBhdGh9LmApO1xuICAgIH1cblxuICAgIC8vIFBhdGggaXMgb2YgdGhlIGZvcm0gJy9jb2xsZWN0aW9uL25hbWVbL3ZlcnNpb25dJ1xuICAgIGNvbnN0IHNlZ21lbnRzID0gKGJhc2VVcmkucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCAhPT0gMyAmJiBzZWdtZW50cy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQga2V5cyBpZGVudGlmaWVyOiAke21hc3RlcktleVBhdGh9LiBCYWQgbnVtYmVyIG9mIHNlZ21lbnRzOiAke3NlZ21lbnRzLmxlbmd0aH1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICgna2V5cycgIT09IHNlZ21lbnRzWzFdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGtleXMgaWRlbnRpZmllcjogJHttYXN0ZXJLZXlQYXRofS4gc2VnbWVudCBbMV0gc2hvdWxkIGJlIFwia2V5c1wiLCBmb3VuZCBcIiR7c2VnbWVudHNbMV19XCJgXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHZhdWx0VXJsID0gYCR7YmFzZVVyaS5wcm90b2NvbH0vLyR7YmFzZVVyaS5ob3N0fWA7XG4gICAgY29uc3QgbmFtZSA9IHNlZ21lbnRzWzJdO1xuICAgIGNvbnN0IHZlcnNpb24gPSBzZWdtZW50cy5sZW5ndGggPT09IDQgPyBzZWdtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4ge1xuICAgICAgdmF1bHRVcmwsXG4gICAgICBuYW1lLFxuICAgICAgdmVyc2lvblxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGF6dXJlS2V5VmF1bHRTaWduZWRIYXNoZWREYXRhKGNyeXB0b0NsaWVudDogQ3J5cHRvZ3JhcGh5Q2xpZW50LCBkYXRhVG9TaWduOiBCdWZmZXIpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGlmICghY3J5cHRvQ2xpZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F6dXJlIEtWUyBDcnlwdG8gQ2xpZW50IGlzIG5vdCBkZWZpbmVkLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHNpZ25lZERhdGEgPSBhd2FpdCBjcnlwdG9DbGllbnQuc2lnbignUlMyNTYnLCBkYXRhVG9TaWduKTtcblxuICAgIHJldHVybiBCdWZmZXIuZnJvbShzaWduZWREYXRhLnJlc3VsdCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGF6dXJlS2V5VmF1bHRXcmFwKGNyeXB0b0NsaWVudDogQ3J5cHRvZ3JhcGh5Q2xpZW50LCBlbmNyeXB0aW9uQWxnb3JpdGhtOiBzdHJpbmcsIGNvbHVtbkVuY3J5cHRpb25LZXk6IEJ1ZmZlcik6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgaWYgKCFjcnlwdG9DbGllbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXp1cmUgS1ZTIENyeXB0byBDbGllbnQgaXMgbm90IGRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFjb2x1bW5FbmNyeXB0aW9uS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbHVtbiBlbmNyeXB0aW9uIGtleSBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCB3cmFwcGVkS2V5ID0gYXdhaXQgY3J5cHRvQ2xpZW50LndyYXBLZXkoZW5jcnlwdGlvbkFsZ29yaXRobSBhcyBLZXlXcmFwQWxnb3JpdGhtLCBjb2x1bW5FbmNyeXB0aW9uS2V5KTtcblxuICAgIHJldHVybiBCdWZmZXIuZnJvbSh3cmFwcGVkS2V5LnJlc3VsdCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGF6dXJlS2V5VmF1bHRVbldyYXAoY3J5cHRvQ2xpZW50OiBDcnlwdG9ncmFwaHlDbGllbnQsIGVuY3J5cHRpb25BbGdvcml0aG06IHN0cmluZywgZW5jcnlwdGVkQ29sdW1uRW5jcnlwdGlvbktleTogQnVmZmVyKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgICBpZiAoIWNyeXB0b0NsaWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBenVyZSBLVlMgQ3J5cHRvIENsaWVudCBpcyBub3QgZGVmaW5lZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIWVuY3J5cHRpb25BbGdvcml0aG0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiBBbGdvcml0aG0gY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgaWYgKCFlbmNyeXB0ZWRDb2x1bW5FbmNyeXB0aW9uS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRlZCBjb2x1bW4gZW5jcnlwdGlvbiBrZXkgY2Fubm90IGJlIG51bGwuJyk7XG4gICAgfVxuXG4gICAgaWYgKGVuY3J5cHRlZENvbHVtbkVuY3J5cHRpb25LZXkubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRlZCBDb2x1bW4gRW5jcnlwdGlvbiBLZXkgbGVuZ3RoIHNob3VsZCBub3QgYmUgemVyby4nKTtcbiAgICB9XG5cbiAgICBjb25zdCB1bndyYXBwZWRLZXkgPSBhd2FpdCBjcnlwdG9DbGllbnQudW53cmFwS2V5KGVuY3J5cHRpb25BbGdvcml0aG0gYXMgS2V5V3JhcEFsZ29yaXRobSwgZW5jcnlwdGVkQ29sdW1uRW5jcnlwdGlvbktleSk7XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20odW53cmFwcGVkS2V5LnJlc3VsdCk7XG4gIH1cblxuICBwcml2YXRlIGdldEFLVktleVNpemUocmV0cmlldmVkS2V5OiBLZXlWYXVsdEtleSk6IG51bWJlciB7XG4gICAgaWYgKCFyZXRyaWV2ZWRLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmV0cmlldmVkIGtleSBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gcmV0cmlldmVkS2V5LmtleTtcblxuICAgIGlmICgha2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSBkb2VzIG5vdCBleGlzdCAke3JldHJpZXZlZEtleS5uYW1lfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGt0eTogc3RyaW5nIHwgdW5kZWZpbmVkID0ga2V5ICYmIGtleS5rdHkgJiYga2V5Lmt0eS50b1N0cmluZygpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICBpZiAoIWt0eSB8fCAnUlNBJy5sb2NhbGVDb21wYXJlKGt0eSwgJ2VuJykgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHVzZSBhIG5vbi1SU0Ega2V5OiAke2t0eX0uYCk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5TGVuZ3RoID0ga2V5ICYmIGtleS5uICYmIGtleS5uLmxlbmd0aDtcblxuICAgIHJldHVybiBrZXlMZW5ndGggfHwgMDtcbiAgfVxuXG4gIHByaXZhdGUgdmFsaWRhdGVFbmNyeXB0aW9uQWxnb3JpdGhtKGVuY3J5cHRpb25BbGdvcml0aG06IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKCFlbmNyeXB0aW9uQWxnb3JpdGhtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBlbmNyeXB0aW9uIGFsZ29yaXRobSBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICB9XG5cbiAgICBpZiAoJ1JTQV9PQUVQJy5sb2NhbGVDb21wYXJlKGVuY3J5cHRpb25BbGdvcml0aG0udG9VcHBlckNhc2UoKSwgJ2VuJykgPT09IDApIHtcbiAgICAgIGVuY3J5cHRpb25BbGdvcml0aG0gPSAnUlNBLU9BRVAnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJzYUVuY3J5cHRpb25BbGdvcml0aG1XaXRoT0FFUEZvckFLVi5sb2NhbGVDb21wYXJlKGVuY3J5cHRpb25BbGdvcml0aG0udHJpbSgpLnRvVXBwZXJDYXNlKCksICdlbicpICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQga2V5IGVuY3J5cHRpb24gYWxnb3JpdGhtIHNwZWNpZmllZDogJHtlbmNyeXB0aW9uQWxnb3JpdGhtfS4gRXhwZWN0ZWQgdmFsdWU6ICR7dGhpcy5yc2FFbmNyeXB0aW9uQWxnb3JpdGhtV2l0aE9BRVBGb3JBS1Z9LmApO1xuICAgIH1cblxuICAgIHJldHVybiBlbmNyeXB0aW9uQWxnb3JpdGhtO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUdBLElBQUFBLFNBQUEsR0FBQUMsT0FBQTtBQUNBLElBQUFDLGFBQUEsR0FBQUQsT0FBQTtBQUNBLElBQUFFLE9BQUEsR0FBQUYsT0FBQTtBQUNBLElBQUFHLElBQUEsR0FBQUgsT0FBQTtBQU5BO0FBQ0E7O0FBYU8sTUFBTUkscUNBQXFDLENBQUM7RUFDakNDLElBQUk7RUFDWkMsR0FBRztFQUNNQyxvQ0FBb0M7RUFDcENDLFlBQVk7RUFDckJDLFdBQVc7RUFDRkMsdUJBQXVCO0VBQ2hDQyxTQUFTO0VBRWpCQyxXQUFXQSxDQUFDQyxRQUFnQixFQUFFQyxTQUFpQixFQUFFQyxRQUFnQixFQUFFO0lBQ2pFLElBQUksQ0FBQ1YsSUFBSSxHQUFHLGlCQUFpQjtJQUM3QixJQUFJLENBQUNLLHVCQUF1QixHQUFHLGlCQUFpQjtJQUNoRCxJQUFJLENBQUNILG9DQUFvQyxHQUFHLFVBQVU7SUFDdEQsSUFBSSxDQUFDQyxZQUFZLEdBQUdRLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdkMsSUFBSSxDQUFDUixXQUFXLEdB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